{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "3601d708",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: geojson in ./anaconda3/lib/python3.10/site-packages (3.0.1)\n",
      "Requirement already satisfied: pyproj in ./anaconda3/lib/python3.10/site-packages (3.5.0)\n",
      "Requirement already satisfied: certifi in ./anaconda3/lib/python3.10/site-packages (from pyproj) (2022.12.7)\n",
      "Collecting shapely\n",
      "  Downloading shapely-2.0.1-cp310-cp310-macosx_10_9_x86_64.whl (1.4 MB)\n",
      "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.4/1.4 MB\u001b[0m \u001b[31m14.8 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m00:01\u001b[0m00:01\u001b[0m\n",
      "\u001b[?25hRequirement already satisfied: numpy>=1.14 in ./anaconda3/lib/python3.10/site-packages (from shapely) (1.23.5)\n",
      "Installing collected packages: shapely\n",
      "Successfully installed shapely-2.0.1\n"
     ]
    }
   ],
   "source": [
    "!pip install geojson\n",
    "!pip install pyproj\n",
    "!pip install shapely\n",
    "import openpyxl\n",
    "import networkx as nx\n",
    "import pickle,json\n",
    "from scipy import spatial\n",
    "from geojson import Feature, FeatureCollection, dump\n",
    "from shapely.geometry import LineString, Polygon, Point\n",
    "import plotly.graph_objs as go\n",
    "import pyproj"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b8942dfd",
   "metadata": {},
   "outputs": [],
   "source": [
    "geod = pyproj.Geod(ellps='WGS84')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c4374a74",
   "metadata": {},
   "outputs": [],
   "source": [
    "def dist(p0,p1): #функция рассчета расстояния в WGS84\n",
    "    a,b= Point(p0),Point(p1)\n",
    "    angle1,angle2,distance1 = geod.inv(a.x, a.y, b.x, b.y)\n",
    "    return distance1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "4f8b5b53",
   "metadata": {},
   "outputs": [],
   "source": [
    "def search_nearest_point(Tree_Graph, point): #функция поиска ближайшей точки в KDTree\n",
    "    #поиск ближайшей точки в KDTree\n",
    "    sub = Tree_Graph.query([point],1)\n",
    "    #получаем индекс ближайшей точки\n",
    "    id_node = sub[1].tolist()[0]\n",
    "    #координаты ближайше точки \n",
    "    closest_node = (Tree_Graph.data[id_node][0],Tree_Graph.data[id_node][1])\n",
    "    return closest_node"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "faaa4dbd",
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_xlsx_data ():  #функция чтения xlsx файла с данными об общественном транспорте \n",
    "    Pub_transport, Stops = {},{}\n",
    "\n",
    "    file = 'marshruty-dvizheniya-gorodskogo-transporta.xlsx'\n",
    "    book = openpyxl.load_workbook(file,data_only=True)['Sheet1'] \n",
    "    i=0\n",
    "    for row in book.rows:\n",
    "        if i!=0:\n",
    "            data = [r.value for r in row]            \n",
    "            num_trans  = data[2] # номер общественного транспорта\n",
    "            name_path  = data[3] # наименование маршрута\n",
    "            type_trans = data[4] # тип общественного транспорта\n",
    "            direct     = data[5] # направление общественного транспорта            \n",
    "            name_stop  = data[9] # наименование остановки\n",
    "            c = data[10].split(',') # чтение координат. разделяем string через запятую\n",
    "            id_stop    = data[6]\n",
    "            id_next_stop    = data[7]\n",
    "            coord_stop = (float(c[0]),float(c[1])) # координаты \n",
    "\n",
    "            if type_trans not in Pub_transport.keys():\n",
    "                Pub_transport[type_trans] = {}\n",
    "            if num_trans not in Pub_transport[type_trans].keys():\n",
    "                Pub_transport[type_trans][num_trans]={}\n",
    "            if direct not in Pub_transport[type_trans][num_trans].keys():\n",
    "                Pub_transport[type_trans][num_trans][direct]= {'name_path': name_path, 'stops': [], 'id_stops' :[] }\n",
    "            Pub_transport[type_trans][num_trans][direct]['stops'].append(coord_stop)\n",
    "            Pub_transport[type_trans][num_trans][direct]['id_stops'].append(id_next_stop)\n",
    "            \n",
    "            if id_stop not in Stops.keys():\n",
    "                Stops[id_stop] = {'id': id_stop, 'name_stops': name_stop, 'coordinates': coord_stop, 'PT_routes' :[]}\n",
    "            Stops[id_stop]['PT_routes'].append((type_trans,num_trans,direct))\n",
    "        i+=1\n",
    "\n",
    "\n",
    "\n",
    "    # добавим последную остановку маршрута, она была записана в столбце ID следующей в последней строке маршрута\n",
    "    for type_tr in Pub_transport.keys():\n",
    "        for num_tr in  Pub_transport[type_tr].keys():\n",
    "            for direct in Pub_transport[type_tr][num_tr].keys():\n",
    "                stop = Pub_transport[type_tr][num_tr][direct]['id_stops'][-1]\n",
    "                # к сожалению в данных не для всех ID остановок есть координата. Это финальные точки маршрута, где нет обратно посадки\n",
    "                try:\n",
    "                    Pub_transport[type_tr][num_tr][direct]['stops'].append(Stops[stop]['coordinates'])\n",
    "                except:pass\n",
    "    #сохраняем данные маршрутов в Pickle, чтобы не собирать заново и возвращать словарь в том же виде, как мы его создали  \n",
    "    with open('public_transport.pickle', 'wb') as handle: \n",
    "            pickle.dump(Pub_transport, handle, protocol=pickle.HIGHEST_PROTOCOL)\n",
    "\n",
    "\n",
    "\n",
    "    #сохраняем данные в geojson для визуализации    \n",
    "    features = []\n",
    "    for type_tr in Pub_transport.keys():\n",
    "        for num_tr in Pub_transport[type_tr].keys():\n",
    "            for direct in Pub_transport[type_tr][num_tr].keys():\n",
    "                path = Pub_transport[type_tr][num_tr][direct]['stops']\n",
    "                features.append(Feature(geometry   = LineString(path),\n",
    "                                        properties = {'number' :num_tr , 'direction':direct, 'type':type_tr}))            \n",
    "    feature_collection = FeatureCollection(features)\n",
    "    with open('public_transport.geojson', 'w', encoding='utf-8') as f:\n",
    "            dump(feature_collection, f, ensure_ascii=False, indent=4) \n",
    "\n",
    "\n",
    "    features = []\n",
    "    for id_stop in Stops.keys():\n",
    "        features.append(Feature(geometry   = Point(Stops[id_stop]['coordinates']),\n",
    "                                properties = {'name':Stops[stop]['name_stops'],  'PT_routes': Stops[stop]['PT_routes']}))    \n",
    "    feature_collection = FeatureCollection(features)\n",
    "    with open('stops.geojson', 'w', encoding='utf-8') as f:\n",
    "            dump(feature_collection, f, ensure_ascii=False, indent=4)  \n",
    "    return Pub_transport "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "c0d7804d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# функция чтения данных дорожной карты и создание графа \n",
    "def read_road_graph ():\n",
    "    with open('grath_Spb_updated_1.0.geojson', encoding='utf-8') as json_file:    \n",
    "        data = json.load(json_file)['features'] \n",
    "    del json_file\n",
    "    # создаем направленный граф \n",
    "    G = nx.DiGraph()\n",
    "    for edge in data:\n",
    "        # проверяем, что список координат не пустой\n",
    "        if len(edge['geometry']['coordinates'])!=0:\n",
    "            start  = edge['geometry']['coordinates'][0] #начало ребра\n",
    "            finish = edge['geometry']['coordinates'][1] #конец ребра\n",
    "            \n",
    "            edge_length = dist((start[0],start[1]), (finish[0],finish[1])) # рассчитываем длину ребра\n",
    "            G.add_edge((start[0],start[1]), (finish[0],finish[1]), weight=edge_length)  \n",
    "    \n",
    "    del start,finish, edge,data,edge_length\n",
    "\n",
    " \n",
    "    #сохраняем граф дорог в Pickle, чтобы не собирать заново и возвращать структуру nx.DiGraph\n",
    "    with open('grath_Spb.pickle', 'wb') as handle: \n",
    "        pickle.dump(G, handle, protocol=pickle.HIGHEST_PROTOCOL)\n",
    "    return G"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "00785bc7",
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'marshruty-dvizheniya-gorodskogo-transporta.xlsx'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[13], line 3\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m      2\u001b[0m     \u001b[38;5;66;03m# пытаемся прочитать файл, если уже его создавали \u001b[39;00m\n\u001b[0;32m----> 3\u001b[0m     \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mpublic_transport.pickle\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mrb\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m f:\n\u001b[1;32m      4\u001b[0m         Pub_transport \u001b[38;5;241m=\u001b[39m pickle\u001b[38;5;241m.\u001b[39mload(f) \n",
      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/IPython/core/interactiveshell.py:282\u001b[0m, in \u001b[0;36m_modified_open\u001b[0;34m(file, *args, **kwargs)\u001b[0m\n\u001b[1;32m    276\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[1;32m    277\u001b[0m         \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mIPython won\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mt let you open fd=\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfile\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m by default \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    278\u001b[0m         \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas it is likely to crash IPython. If you know what you are doing, \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    279\u001b[0m         \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124myou can use builtins\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m open.\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    280\u001b[0m     )\n\u001b[0;32m--> 282\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mio_open\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'public_transport.pickle'",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[13], line 8\u001b[0m\n\u001b[1;32m      5\u001b[0m     f\u001b[38;5;241m.\u001b[39mclose()\n\u001b[1;32m      6\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m:\n\u001b[1;32m      7\u001b[0m     \u001b[38;5;66;03m# если такого файла нет, вызываем функцию чтения файла и сохраняем его в pickle\u001b[39;00m\n\u001b[0;32m----> 8\u001b[0m     Pub_transport \u001b[38;5;241m=\u001b[39m \u001b[43mread_xlsx_data\u001b[49m\u001b[43m \u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     11\u001b[0m \u001b[38;5;66;03m# границы административного района\u001b[39;00m\n\u001b[1;32m     12\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mopen\u001b[39m(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mГраницы административных районов (1).geojson\u001b[39m\u001b[38;5;124m'\u001b[39m, encoding\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mutf-8\u001b[39m\u001b[38;5;124m'\u001b[39m) \u001b[38;5;28;01mas\u001b[39;00m json_file:\n",
      "Cell \u001b[0;32mIn[7], line 5\u001b[0m, in \u001b[0;36mread_xlsx_data\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m Pub_transport, Stops \u001b[38;5;241m=\u001b[39m {},{}\n\u001b[1;32m      4\u001b[0m file \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmarshruty-dvizheniya-gorodskogo-transporta.xlsx\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m----> 5\u001b[0m book \u001b[38;5;241m=\u001b[39m \u001b[43mopenpyxl\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mload_workbook\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile\u001b[49m\u001b[43m,\u001b[49m\u001b[43mdata_only\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43;01mTrue\u001b[39;49;00m\u001b[43m)\u001b[49m[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mSheet1\u001b[39m\u001b[38;5;124m'\u001b[39m] \n\u001b[1;32m      6\u001b[0m i\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0\u001b[39m\n\u001b[1;32m      7\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m row \u001b[38;5;129;01min\u001b[39;00m book\u001b[38;5;241m.\u001b[39mrows:\n",
      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/openpyxl/reader/excel.py:315\u001b[0m, in \u001b[0;36mload_workbook\u001b[0;34m(filename, read_only, keep_vba, data_only, keep_links)\u001b[0m\n\u001b[1;32m    288\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mload_workbook\u001b[39m(filename, read_only\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mFalse\u001b[39;00m, keep_vba\u001b[38;5;241m=\u001b[39mKEEP_VBA,\n\u001b[1;32m    289\u001b[0m                   data_only\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mFalse\u001b[39;00m, keep_links\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m):\n\u001b[1;32m    290\u001b[0m     \u001b[38;5;124;03m\"\"\"Open the given filename and return the workbook\u001b[39;00m\n\u001b[1;32m    291\u001b[0m \n\u001b[1;32m    292\u001b[0m \u001b[38;5;124;03m    :param filename: the path to open or a file-like object\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    313\u001b[0m \n\u001b[1;32m    314\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[0;32m--> 315\u001b[0m     reader \u001b[38;5;241m=\u001b[39m \u001b[43mExcelReader\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfilename\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mread_only\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mkeep_vba\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    316\u001b[0m \u001b[43m                        \u001b[49m\u001b[43mdata_only\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mkeep_links\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    317\u001b[0m     reader\u001b[38;5;241m.\u001b[39mread()\n\u001b[1;32m    318\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m reader\u001b[38;5;241m.\u001b[39mwb\n",
      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/openpyxl/reader/excel.py:124\u001b[0m, in \u001b[0;36mExcelReader.__init__\u001b[0;34m(self, fn, read_only, keep_vba, data_only, keep_links)\u001b[0m\n\u001b[1;32m    122\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__init__\u001b[39m(\u001b[38;5;28mself\u001b[39m,  fn, read_only\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mFalse\u001b[39;00m, keep_vba\u001b[38;5;241m=\u001b[39mKEEP_VBA,\n\u001b[1;32m    123\u001b[0m               data_only\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mFalse\u001b[39;00m, keep_links\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m):\n\u001b[0;32m--> 124\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39marchive \u001b[38;5;241m=\u001b[39m \u001b[43m_validate_archive\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfn\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    125\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mvalid_files \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39marchive\u001b[38;5;241m.\u001b[39mnamelist()\n\u001b[1;32m    126\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mread_only \u001b[38;5;241m=\u001b[39m read_only\n",
      "File \u001b[0;32m~/anaconda3/lib/python3.10/site-packages/openpyxl/reader/excel.py:96\u001b[0m, in \u001b[0;36m_validate_archive\u001b[0;34m(filename)\u001b[0m\n\u001b[1;32m     89\u001b[0m             msg \u001b[38;5;241m=\u001b[39m (\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mopenpyxl does not support \u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m file format, \u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m     90\u001b[0m                    \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mplease check you can open \u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m     91\u001b[0m                    \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mit with Excel first. \u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m     92\u001b[0m                    \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mSupported formats are: \u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m'\u001b[39m) \u001b[38;5;241m%\u001b[39m (file_format,\n\u001b[1;32m     93\u001b[0m                                                    \u001b[38;5;124m'\u001b[39m\u001b[38;5;124m,\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;241m.\u001b[39mjoin(SUPPORTED_FORMATS))\n\u001b[1;32m     94\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m InvalidFileException(msg)\n\u001b[0;32m---> 96\u001b[0m archive \u001b[38;5;241m=\u001b[39m \u001b[43mZipFile\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfilename\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mr\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m     97\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m archive\n",
      "File \u001b[0;32m~/anaconda3/lib/python3.10/zipfile.py:1249\u001b[0m, in \u001b[0;36mZipFile.__init__\u001b[0;34m(self, file, mode, compression, allowZip64, compresslevel, strict_timestamps)\u001b[0m\n\u001b[1;32m   1247\u001b[0m \u001b[38;5;28;01mwhile\u001b[39;00m \u001b[38;5;28;01mTrue\u001b[39;00m:\n\u001b[1;32m   1248\u001b[0m     \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[0;32m-> 1249\u001b[0m         \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfp \u001b[38;5;241m=\u001b[39m \u001b[43mio\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfile\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfilemode\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m   1250\u001b[0m     \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mOSError\u001b[39;00m:\n\u001b[1;32m   1251\u001b[0m         \u001b[38;5;28;01mif\u001b[39;00m filemode \u001b[38;5;129;01min\u001b[39;00m modeDict:\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'marshruty-dvizheniya-gorodskogo-transporta.xlsx'"
     ]
    }
   ],
   "source": [
    "try:\n",
    "    # пытаемся прочитать файл, если уже его создавали \n",
    "    with open('public_transport.pickle', 'rb') as f:\n",
    "        Pub_transport = pickle.load(f) \n",
    "    f.close()\n",
    "except:\n",
    "    # если такого файла нет, вызываем функцию чтения файла и сохраняем его в pickle\n",
    "    Pub_transport = read_xlsx_data ()\n",
    "    \n",
    "\n",
    "# границы административного района\n",
    "with open('Границы административных районов (1).geojson', encoding='utf-8') as json_file:\n",
    "    data = json.load(json_file)['features'] \n",
    "for area in data:\n",
    "    if area['properties']['Name      ']=='Центральный':\n",
    "        list_point = [(point[0],point[1]) for point in area['geometry']['coordinates'][0][0]]\n",
    "        region_borders = Polygon(list_point) #созадем полигон из границ админ района   \n",
    "del list_point,area,data,json_file\n",
    "\n",
    "# для нашей задачи используем только Автобусы и Троллейбусы\n",
    "Area_transport = {'Троллейбус':{}, 'Автобус':{}} # словарь, где будем хранить данные о маршрутах Центрального района\n",
    "\n",
    "for type_tr in ['Троллейбус', 'Автобус']:\n",
    "    for num_tr in Pub_transport[type_tr].keys():\n",
    "        for direction in Pub_transport[type_tr][num_tr].keys():\n",
    "            list_of_stops = Pub_transport[type_tr][num_tr][direction]['stops'] # набор остановок маршрута\n",
    "            # проверяем, что маршрут проходит через Центральный район\n",
    "            if LineString(list_of_stops).intersects(region_borders) == True:\n",
    "                Area_transport[type_tr][num_tr] = Pub_transport[type_tr][num_tr]                    \n",
    "                break \n",
    "del type_tr,num_tr,direction,list_of_stops,Pub_transport"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc752e5a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# границы административного района\n",
    "with open('Границы административных районов (1).geojson', encoding='utf-8') as json_file:\n",
    "    data = json.load(json_file)['features'] \n",
    "for area in data:\n",
    "    if area['properties']['Name      ']=='Центральный':\n",
    "        list_point = [(point[0],point[1]) for point in area['geometry']['coordinates'][0][0]]\n",
    "        region_borders = Polygon(list_point) #созадем полигон из границ админ района   \n",
    "del list_point,area,data,json_file\n",
    "\n",
    "# для нашей задачи используем только Автобусы и Троллейбусы\n",
    "Area_transport = {'Троллейбус':{}, 'Автобус':{}} # словарь, где будем хранить данные о маршрутах Центрального района\n",
    "\n",
    "for type_tr in ['Троллейбус', 'Автобус']:\n",
    "    for num_tr in Pub_transport[type_tr].keys():\n",
    "        for direction in Pub_transport[type_tr][num_tr].keys():\n",
    "            list_of_stops = Pub_transport[type_tr][num_tr][direction]['stops'] # набор остановок маршрута\n",
    "            # проверяем, что маршрут проходит через Центральный район\n",
    "            if LineString(list_of_stops).intersects(region_borders) == True:\n",
    "                Area_transport[type_tr][num_tr] = Pub_transport[type_tr][num_tr]                    \n",
    "                break \n",
    "del type_tr,num_tr,direction,list_of_stops,Pub_transport"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
